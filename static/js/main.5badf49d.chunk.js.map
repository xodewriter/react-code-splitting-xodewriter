{"version":3,"sources":["components/Spinner.js","components/Api.js","App.js","index.js"],"names":["Spinner","className","role","wrapPromise","promise","result","status","suspender","then","r","e","read","resource","greetPromise","msg","d","Date","getHours","Promise","resolve","reject","setTimeout","fetchGreet","awesomePromise","todoPromise","greet","awesome","todo","fetchData","Greet","greeting","Awesome","Todo","App","Suspense","fallback","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"iMAMeA,EAJC,WACf,OAAO,qBAAKC,UAAU,2BAA2BC,KAAK,YCgDvD,SAASC,EAAYC,GAEpB,IAEIC,EAFAC,EAAS,UAKTC,EAAYH,EAAQI,MACvB,SAAAC,GACCH,EAAS,WACTD,EAASI,KAEV,SAAAC,GACCJ,EAAS,WACTD,EAASK,KAKX,MAAO,CAKNC,KALM,WAML,GAAe,YAAXL,EAAsB,MAAMC,EAChC,MAAe,aAAXD,GACW,aAAXA,EAD8BD,OAClC,ICtEH,IAAMO,EDLC,WACN,IAAIC,EAcL,WACC,IACIC,EADEC,EAAI,IAAIC,KAId,OAFoBF,EAApBC,EAAEE,UAAY,GAAY,gBAA0B,iBAE7C,IAAIC,SAAQ,SAACC,EAASC,GAC5BC,YAAW,WACVF,EAAQL,KACN,QAtBeQ,GACfC,EA2BG,IAAIL,SAAQ,SAACC,EAASC,GAC5BC,YAAW,WACVF,EAAQ,sBACN,QA7BAK,EAmCG,IAAIN,SAAQ,SAACC,EAASC,GAC5BC,YAAW,WACVF,EAAQ,wBACN,QApCJ,MAAO,CACNM,MAAOtB,EAAYU,GACnBa,QAASvB,EAAYoB,GACrBI,KAAMxB,EAAYqB,ICHHI,GAKjB,SAASC,IACR,IAAMC,EAAWlB,EAASa,MAAMd,OAChC,OAAO,6BAAKmB,IAIb,SAASC,IACR,IAAML,EAAUd,EAASc,QAAQf,OACjC,OAAO,6BAAKe,IAIb,SAASM,IACR,IAAML,EAAOf,EAASe,KAAKhB,OAC3B,OAAO,6BAAKgB,IA0DEM,MAvDf,WACC,OACC,sBAAKhC,UAAU,MAAf,UACC,uDAEC,uBAFD,0BAIA,+BACC,wHAIA,8JAIA,wSAMA,kQAMA,sOAIC,4FAIF,cAAC,IAAMiC,SAAP,CAAgBC,SAAU,6DAA1B,SACC,cAACN,EAAD,MAED,cAAC,IAAMK,SAAP,CAAgBC,SAAU,4DAA1B,SACC,cAACJ,EAAD,MAED,cAAC,IAAMG,SAAP,CACCC,SACC,qCACC,cAAC,EAAD,IACA,8DAJH,SAOC,cAACH,EAAD,UC1EJI,IAASC,OACR,cAAC,IAAMC,WAAP,UACC,cAAC,EAAD,MAEDC,SAASC,eAAe,U","file":"static/js/main.5badf49d.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst Spinner = () => {\r\n\treturn <div className='spinner-border text-info' role='status'></div>;\r\n};\r\n\r\nexport default Spinner;\r\n","/* STEP 3: Last step but I like to keep this at the top */\r\n\r\n// Close the circle by fetching data\r\nexport function fetchData() {\r\n\tlet greetPromise = fetchGreet();\r\n\tlet awesomePromise = fetchAwesome();\r\n\tlet todoPromise = fetchTodo();\r\n\r\n\treturn {\r\n\t\tgreet: wrapPromise(greetPromise),\r\n\t\tawesome: wrapPromise(awesomePromise),\r\n\t\ttodo: wrapPromise(todoPromise),\r\n\t};\r\n}\r\n\r\n/* STEP 1: Create promises to fetch data */\r\n\r\n// Promise to fetch a greeting message\r\nfunction fetchGreet() {\r\n\tconst d = new Date();\r\n\tlet msg;\r\n\td.getHours >= 12 ? (msg = 'Good Morning!') : (msg = 'Good Afternoon');\r\n\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve(msg);\r\n\t\t}, 2000);\r\n\t});\r\n}\r\n\r\n// Promise to fetch an awesome message\r\nfunction fetchAwesome() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('You are Awesome!');\r\n\t\t}, 4000);\r\n\t});\r\n}\r\n\r\n// Promise to fetch something Todo\r\nfunction fetchTodo() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve(\"It's time to code!\");\r\n\t\t}, 6000);\r\n\t});\r\n}\r\n\r\n/* STEP 2: Create wrapper to dynamically wrap each of the promises, or at least the onece we decide to use in STEP 3 */\r\n\r\n// Wrapper for promises\r\nfunction wrapPromise(promise) {\r\n\t// default status\r\n\tlet status = 'pending';\r\n\t// eventually holds the value of either 1) \"resolved\" promise 2) \"rejected\" promise\r\n\tlet result;\r\n\t// takes the promise argument and carries out the promise to try and resolve it\r\n\t// it will either 1) resolve \"r\" or 2) reject \"e\"\r\n\tlet suspender = promise.then(\r\n\t\tr => {\r\n\t\t\tstatus = 'resolved';\r\n\t\t\tresult = r;\r\n\t\t},\r\n\t\te => {\r\n\t\t\tstatus = 'rejected';\r\n\t\t\tresult = e;\r\n\t\t},\r\n\t);\r\n\r\n\t// Return object\r\n\treturn {\r\n\t\t// Conditionally runs code\r\n\t\t// If pending (default), promise.then runs & returns a result of either resolved or rejected\r\n\t\t// If resolved, a succesful response object is stored to the result variable\r\n\t\t// If status, an error object is stored to the result variable\r\n\t\tread() {\r\n\t\t\tif (status === 'pending') throw suspender;\r\n\t\t\tif (status === 'resolved') return result;\r\n\t\t\tif (status === 'rejected') return result;\r\n\t\t},\r\n\t};\r\n}\r\n","import './App.css';\r\nimport React from 'react';\r\nimport Spinner from './components/Spinner';\r\n\r\n// Import the declarative pattern\r\nimport { fetchData } from './components/Api';\r\n\r\n// Extract fetch data to resource to write cleaner & easier to read code\r\nconst resource = fetchData();\r\n\r\n// Create Components; Can be done in an external file but I'm leaving it here for simplicity\r\n\r\n// Greet Component\r\nfunction Greet() {\r\n\tconst greeting = resource.greet.read();\r\n\treturn <h3>{greeting}</h3>;\r\n}\r\n\r\n// Awesome Component\r\nfunction Awesome() {\r\n\tconst awesome = resource.awesome.read();\r\n\treturn <h3>{awesome}</h3>;\r\n}\r\n\r\n// Todo Component\r\nfunction Todo() {\r\n\tconst todo = resource.todo.read();\r\n\treturn <h3>{todo}</h3>;\r\n}\r\n\r\nfunction App() {\r\n\treturn (\r\n\t\t<div className='App'>\r\n\t\t\t<h1>\r\n\t\t\t\tThe React Concurrency\r\n\t\t\t\t<br /> Declarative Pattern\r\n\t\t\t</h1>\r\n\t\t\t<ul>\r\n\t\t\t\t<li>\r\n\t\t\t\t\tSee Api.js to review the \"declarative\" pattern. React is moving\r\n\t\t\t\t\ttowards this approach.\r\n\t\t\t\t</li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\tThis demo has 3 promises: [1] Greet which takes 3 seconds, [2] Awesome\r\n\t\t\t\t\twhich takes 4 seconds, [3] Todo which takes 5 seconds\r\n\t\t\t\t</li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\tPlacement of React.Suspense matters. If one Suspense is wrapped around\r\n\t\t\t\t\tmultiple components, it suspends until the amount of time of the\r\n\t\t\t\t\tlongest promise and loads everythign at the same time. In this demo\r\n\t\t\t\t\tthe longest promise belongs to Todo which takes 5 seconds.\r\n\t\t\t\t</li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\tUse React.Suspense individually to load suspend one at time until\r\n\t\t\t\t\tready. This approach doesn't wait until the longest promise like the\r\n\t\t\t\t\tlast point and will load as soon as it's ready. It's also the approach\r\n\t\t\t\t\tused in this demo.\r\n\t\t\t\t</li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\tThe fallback can use inline HTML or import a component. For the\r\n\t\t\t\t\tgreeting & awesome message inline styling is used. For the last, both\r\n\t\t\t\t\tinline styling is used and also an imported Spinner component.\r\n\t\t\t\t\t<b> This looks awkward but is strictly for demo purposes</b>\r\n\t\t\t\t</li>\r\n\t\t\t</ul>\r\n\t\t\t{/* Components */}\r\n\t\t\t<React.Suspense fallback={<h3>Loading greeting message...</h3>}>\r\n\t\t\t\t<Greet />\r\n\t\t\t</React.Suspense>\r\n\t\t\t<React.Suspense fallback={<h3>Loading awesome message...</h3>}>\r\n\t\t\t\t<Awesome />\r\n\t\t\t</React.Suspense>\r\n\t\t\t<React.Suspense\r\n\t\t\t\tfallback={\r\n\t\t\t\t\t<>\r\n\t\t\t\t\t\t<Spinner />\r\n\t\t\t\t\t\t<h3>Loading something todo...</h3>\r\n\t\t\t\t\t</>\r\n\t\t\t\t}>\r\n\t\t\t\t<Todo />\r\n\t\t\t</React.Suspense>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n\t<React.StrictMode>\r\n\t\t<App />\r\n\t</React.StrictMode>,\r\n\tdocument.getElementById('root'),\r\n);\r\n"],"sourceRoot":""}