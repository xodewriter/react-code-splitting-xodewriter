(this["webpackJsonpreact-code-splitting"]=this["webpackJsonpreact-code-splitting"]||[]).push([[0],{11:function(e,t,n){"use strict";n.r(t);var s=n(1),i=n.n(s),o=n(3),r=n.n(o),c=(n(8),n(9),n(0)),a=function(){return Object(c.jsx)("div",{className:"spinner-border text-info",role:"status"})};function d(e){var t,n="pending",s=e.then((function(e){n="resolved",t=e}),(function(e){n="rejected",t=e}));return{read:function(){if("pending"===n)throw s;return"resolved"===n||"rejected"===n?t:void 0}}}var l=function(){var e=function(){var e,t=new Date;return e=t.getHours>=12?"Good Morning!":"Good Afternoon",new Promise((function(t,n){setTimeout((function(){t(e)}),2e3)}))}(),t=new Promise((function(e,t){setTimeout((function(){e("You are Awesome!")}),4e3)})),n=new Promise((function(e,t){setTimeout((function(){e("It's time to code!")}),6e3)}));return{greet:d(e),awesome:d(t),todo:d(n)}}();function h(){var e=l.greet.read();return Object(c.jsx)("h3",{children:e})}function u(){var e=l.awesome.read();return Object(c.jsx)("h3",{children:e})}function j(){var e=l.todo.read();return Object(c.jsx)("h3",{children:e})}var m=function(){return Object(c.jsxs)("div",{className:"App",children:[Object(c.jsxs)("h1",{children:["The React Concurrency",Object(c.jsx)("br",{})," Declarative Pattern"]}),Object(c.jsxs)("ul",{children:[Object(c.jsx)("li",{children:'See Api.js to review the "declarative" pattern. React is moving towards this approach.'}),Object(c.jsx)("li",{children:"This demo has 3 promises: [1] Greet which takes 3 seconds, [2] Awesome which takes 4 seconds, [3] Todo which takes 5 seconds"}),Object(c.jsx)("li",{children:"Placement of React.Suspense matters. If one Suspense is wrapped around multiple components, it suspends until the amount of time of the longest promise and loads everythign at the same time. In this demo the longest promise belongs to Todo which takes 5 seconds."}),Object(c.jsx)("li",{children:"Use React.Suspense individually to load suspend one at time until ready. This approach doesn't wait until the longest promise like the last point and will load as soon as it's ready. It's also the approach used in this demo."}),Object(c.jsxs)("li",{children:["The fallback can use inline HTML or import a component. For the greeting & awesome message inline styling is used. For the last, both inline styling is used and also an imported Spinner component.",Object(c.jsx)("b",{children:" This looks awkward but is strictly for demo purposes"})]})]}),Object(c.jsx)(i.a.Suspense,{fallback:Object(c.jsx)("h3",{children:"Loading greeting message..."}),children:Object(c.jsx)(h,{})}),Object(c.jsx)(i.a.Suspense,{fallback:Object(c.jsx)("h3",{children:"Loading awesome message..."}),children:Object(c.jsx)(u,{})}),Object(c.jsx)(i.a.Suspense,{fallback:Object(c.jsxs)(c.Fragment,{children:[Object(c.jsx)(a,{}),Object(c.jsx)("h3",{children:"Loading something todo..."})]}),children:Object(c.jsx)(j,{})})]})};r.a.render(Object(c.jsx)(i.a.StrictMode,{children:Object(c.jsx)(m,{})}),document.getElementById("root"))},8:function(e,t,n){},9:function(e,t,n){}},[[11,1,2]]]);
//# sourceMappingURL=main.5badf49d.chunk.js.map